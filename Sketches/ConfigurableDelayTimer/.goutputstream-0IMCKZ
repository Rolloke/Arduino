
#include "Input.h"
#include "Output.h"

InputPin* InputPin::mThisForISR = 0;

InputPin::InputPin() : 
mPin(0),
mBinary(true),
mEdge(no_edge),
mReport(false),
mValue(0),
mThreshold(-1),
mBelowThresholdValue(false),
mDeBounce(0),
mRepeat_ms(0),
mDelay_ms(0),
mTime(0),
mConnection(0)
{
  
}

void InputPin::tick(unsigned long aNow)
{
  if (mPin)
  {
	  get_value(aNow);
  }
}

bool InputPin::setPin(uint8_t aPin, bool aBinary)
{
  mPin    = aPin;
  pinMode(mPin, INPUT);
  mBinary = aBinary;
  if (mBinary) mEdge = change;
}

void InputPin::ISRstatic()
{
  mThisForISR->InterruptSR();  
}

void InputPin::InterruptSR()
{
  triggerConnection(digitalRead(mPin));
}

void InputPin::setEdge(uint8_t aEdge)
{
  mEdge = aEdge;
  switch (aEdge)
  {
    case Switch:
      mThreshold = released;
      mDeBounce  = 50;
      digitalWrite(mPin, HIGH);
    break;
    default:
      if (aEdge & interrupt)
      {
        int mode = CHANGE;
        switch(aEdge & interrupt_mask)
        {
          case rising:  mode = RISING;  break;
          case falling: mode = FALLING; break;
          case low:     mode = LOW;     break;
          case high:    mode = HIGH;    break;
        }
        attachInterrupt(digitalPinToInterrupt(mPin), ISRstatic, mode);
        mThisForISR = this; 
      }
      break;
  }
}

void InputPin::setRepeat(uint16_t aRepeat_ms)
{
  mRepeat_ms = aRepeat_ms;
}

void InputPin::setDelay(uint16_t aDelay_ms)
{
  mDelay_ms = aDelay_ms;
}

void InputPin::setDebounce(uint16_t aDebounce_ms)
{
  mDeBounce = aDebounce_ms;
}

void InputPin::setConnection(OutputPin* aPin)
{
  mConnection = aPin;
}

void InputPin::setThreshold(uint16_t aThreshold)
{
  mThreshold = aThreshold;
  mBelowThresholdValue = mValue < mThreshold;
}

uint16_t InputPin::getValue() const
{
  return mValue;
}

void InputPin::setValue(uint16_t aValue)
{
  if (mPin)
  {
    digitalWrite(mPin, aValue);
  }
}

void InputPin::report(bool aR)
{
  mReport = aR;
}

void InputPin::get_value(unsigned long aNow)
{
  if (mBinary)
  {
    // binary --------------------------------------------------------------------
    uint16_t fValue = digitalRead(mPin); // 0, 1
    switch (mEdge)
    {
      // --------------------------------------------------------------------       
      case rising:
        if (fValue != 0 && mValue == 0)
        {
          mValue = fValue;
          triggerConnection();
        }
        break;
      case falling:
        if (fValue == 0 && mValue != 0)
        {
          mValue = fValue;
          triggerConnection(fValue);
        }
        break;
      case change:
        if (fValue != mValue)
        {
          mValue = fValue;
          triggerConnection(mValue);
        }
        break;
      // --------------------------------------------------------------------------       
      // handle as low active switch with internal pullup resistor
      case Switch:
        if (fValue == LOW) // low means button is pressed
        {
          switch (mThreshold)
          {
            case released:
              mTime = aNow + mDeBounce;
              mThreshold = pressed;
              break;
            // --------------------------------------------------------------------
            case pressed: // button
              if (aNow >= mTime)
              {
                triggerConnection();
                mThreshold = fired;
                if (mDelay_ms > 0)
                {
                  mTime = aNow + mDelay_ms;
                  mThreshold = delayed;
                }
                else if (mRepeat_ms > 0)
                {
                  mTime = aNow + mRepeat_ms;
                  mThreshold = repeated;
                }
              }
              break;
            // --------------------------------------------------------------------
            case delayed: // second trigger
              if (aNow >= mTime)
              {
                triggerConnection();
                mThreshold = fired;
                if (mRepeat_ms > 0)
                {
                  mTime = aNow + mRepeat_ms;
                  mThreshold = repeated;
                }
              }
              break;
            // --------------------------------------------------------------------
            case repeated: // further triggers
              if (aNow >= mTime)
              {
                triggerConnection();
                mTime = aNow + mRepeat_ms;
              }
              break;
          }
        }
        else  // fValue == HIGH
        {
          // --------------------------------------------------------------------
          if (mThreshold >= fired) // release button, if it was fired
          {
            triggerConnection(0);
          }
          mThreshold = released;
        }
        break;
      default:
        if (mEdge & interrupt) break;
        triggerConnection();
        break;      
    }
    mValue = fValue;
  }
  else
  {
    // analog --------------------------------------------------------------------
    uint16_t fValue = analogRead(mPin); // 0,...,1023
    if (mThreshold > -1)
    {
      // analog treshold handling --------------------------------------------------
      if (mBelowThresholdValue)
      {
        if (fValue > mThreshold+mDeBounce)
        {
          triggerConnection(1);
          mBelowThresholdValue = false;
        }
      }
      else
      {
        if (fValue < mThreshold-mDeBounce)
        {
          triggerConnection(0);
          mBelowThresholdValue = true;
        }
      }
    }
    else if (mReport && mRepeat_ms)
    {
      // repeated report of values -------------------------------------------------
      if (aNow >= mTime)
      {
        triggerConnection(fValue);
        mTime = aNow + mRepeat_ms;
      }
    }
    else if (abs(fValue - mValue) > mDeBounce && (mEdge & interrupt_mask) == change )
    {
      // analog change of value   --------------------------------------------------
      if (aNow >= mTime)
      {
        triggerConnection(fValue);
        mTime = aNow + max(5, mRepeat_ms);
      }
    }
    mValue = fValue;
  }
}

uint32_t InputPin::getPulseLength(bool aHigh, uint32_t aTimeout)
{
  return pulseIn(mPin, aHigh ? HIGH : LOW, aTimeout);
}


void InputPin::triggerConnection(uint16_t fValue)
{
  if (mConnection)
  {
    mConnection->setValue(mBinary ? fValue : fValue / 4);
  }
  if (mReport)
  {
    Serial.println(fValue);
  }
}

String InputPin::info(bool aShort) const
{
  String fInfo = "Input Pin: " + String(mPin) + (mBinary ? ": binary" : ": analog");
  if (!aShort)
  {
    if (mEdge & interrupt)
    {
      fInfo += ", Interrupt: ";
    }
    else if (mEdge&interrupt_mask)
    {
      fInfo += ", Edge:" + String(mEdge);
    }

    switch ((mEdge&interrupt_mask))
    {
      //case no_edge:fInfo += ": none"; break;
      case rising: fInfo += ": rising"; break;
      case falling:fInfo += ": falling"; break;
      case change: fInfo += ": change"; break;
    }

    if (mEdge&Switch)
    {
      fInfo += ", Low active switch with internal pullup resistor";
      if (mDeBounce) fInfo += ", Pulse trigger after: " + String(mDeBounce) + " ms";
      if (mDelay_ms)    fInfo += ", Delayed 2nd trigger: " + String(mDelay_ms) + " ms";
      if (mRepeat_ms)   fInfo += ", Repeat trigger: " + String(mRepeat_ms) + " ms";
    }

    if (mThreshold > -1 && mEdge != Switch)
    {
      fInfo += ", Threshold Value: " + String(mThreshold);
      if (mDeBounce) fInfo += ", switch threshold (+-): " + String(mDeBounce);
      fInfo += ", value is ";
      if(mBelowThresholdValue) fInfo += "below";
      else                     fInfo += "above";
    }
    if (mReport) fInfo += ", Reporting to serial com";
    if (mRepeat_ms > 0)  fInfo += " request " + String(mRepeat_ms) + " ms interval";
    fInfo += ", Value: " + String(mValue);
    if (mConnection != 0)
    {  
      fInfo += ", Connected to: " + mConnection->info(true);
    }
  }
  return fInfo;
}

uint8_t  InputPin::pin() const
{
  return mPin;
}


